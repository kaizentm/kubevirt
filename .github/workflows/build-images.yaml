name: Build and Push Images

on:
  workflow_call:
    inputs:
      registry:
        description: 'Container registry to push images to'
        required: false
        default: 'ghcr.io'
        type: string
      rpm_image_tag:
        description: 'Tag for custom libvirt and QEMU RPMs images'
        required: false
        default: 'qemu-mshv'
        type: string
      registry_username:
        description: 'Username for container registry (only needed for non-GHCR registries)'
        required: false
        default: ''
        type: string
      registry_password:
        description: 'Password for container registry (only needed for non-GHCR registries)'
        required: false
        default: ''
        type: string
      docker_tag:
        description: 'Docker tag for the built images'
        required: true
        type: string
    outputs:
      image_tag:
        description: 'The tag of the built images'
        value: ${{ inputs.docker_tag }}
      registry:
        description: 'The registry where images were pushed'
        value: ${{ inputs.registry }}

env:
  DOCKER_PREFIX: ${{ inputs.registry }}/${{ github.repository }}
  DOCKER_TAG: ${{ inputs.docker_tag }}
  CUSTOM_LIBVIRT_IMAGE: ${{ format('{0}/{1}/libvirt-rpms:{2}', inputs.registry, github.repository, inputs.rpm_image_tag) }}
  CUSTOM_QEMU_IMAGE: ${{ format('{0}/{1}/qemu-rpms:{2}', inputs.registry, github.repository, inputs.rpm_image_tag) }}

jobs:
  build-push-images:
    runs-on: self-hosted
    permissions: write-all
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Cleanup Docker containers and images
        run: |
           # Remove all running containers
           docker ps -q | xargs -r docker rm -f
           # Remove stopped containers, unused images, networks, and optionally volumes
           docker system prune -f

      - name: Login to Container Registry
        uses: docker/login-action@v1 
        with:
          registry: ${{ inputs.registry }}
          username: ${{ inputs.registry == 'ghcr.io' && github.actor || inputs.registry_username || secrets.REGISTRY_USERNAME }}
          password: ${{ inputs.registry == 'ghcr.io' && secrets.GITHUB_TOKEN || inputs.registry_password || secrets.REGISTRY_PASSWORD }}

      - name: Setup Custom libvirt & qemu RPMs
        run: |
          set -euo pipefail
          echo "Setting up custom libvirt & qemu RPM repos..."

          # Pull pre-built RPM images
          docker pull ${{ env.CUSTOM_LIBVIRT_IMAGE }}
          docker pull ${{ env.CUSTOM_QEMU_IMAGE }}
          
          # Start libvirt repo HTTP server (port 8080) if not running
          if [ "$(docker ps -q -f name=libvirt-rpms-http-server)" ]; then
            echo "Libvirt RPM server already running"
          else
            docker run --rm -dit \
              --name libvirt-rpms-http-server \
              -p 8080:80 \
              ${{ env.CUSTOM_LIBVIRT_IMAGE }}
            sleep 5
          fi          

          # Start qemu repo HTTP server (port 9090) if not running
            if [ "$(docker ps -q -f name=qemu-rpms-http-server)" ]; then
            echo "QEMU RPM server already running"
          else
            docker run --rm -dit \
              --name qemu-rpms-http-server \
              -p 9090:80 \
              ${{ env.CUSTOM_QEMU_IMAGE }}
            sleep 5
          fi

          LIBVIRT_IP=$(docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' libvirt-rpms-http-server)
          QEMU_IP=$(docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' qemu-rpms-http-server)
          echo "Libvirt repo IP: $LIBVIRT_IP"
          echo "QEMU repo IP:    $QEMU_IP"

          # Verify both repos (use their mapped host ports)
          curl -f "http://localhost:8080/x86_64/repodata/repomd.xml" || { echo 'Libvirt repo not accessible'; exit 1; }
          curl -f "http://localhost:9090/x86_64/repodata/repomd.xml" || { echo 'QEMU repo not accessible'; exit 1; }

          # Extract versions (tolerate missing build-info fields)
          LIBVIRT_VERSION=$(curl -s "http://localhost:8080/build-info.json" | jq -r '.libvirt_version // empty') || true
          QEMU_VERSION=$(curl -s "http://localhost:9090/build-info.json" | jq -r '.qemu_version // empty') || true
          echo "Detected libvirt version: ${LIBVIRT_VERSION:-<none>}"
          echo "Detected qemu version:    ${QEMU_VERSION:-<none>}"

          # Build combined repo descriptor so rpm-deps sees both
          cat > custom-repo.yaml <<EOF
          repositories:
          - arch: x86_64
            baseurl: http://$LIBVIRT_IP:80/x86_64/
            name: custom-libvirt
            gpgcheck: 0
            repo_gpgcheck: 0
          - arch: x86_64
            baseurl: http://$QEMU_IP:80/x86_64/
            name: custom-qemu
            gpgcheck: 0
            repo_gpgcheck: 0
          EOF

          echo "Combined custom-repo.yaml:"; cat custom-repo.yaml

          make CUSTOM_REPO=custom-repo.yaml LIBVIRT_VERSION="$LIBVIRT_VERSION" QEMU_VERSION="$QEMU_VERSION" SINGLE_ARCH="x86_64" rpm-deps

          echo "rpm-deps completed with custom libvirt & qemu"

      - name: Build Images
        run: |
          make bazel-build-images 

      - name: Push Images
        run: |
          make bazel-push-images

      - name: Cleanup Custom RPM Servers
        if: always()
        run: |
          docker rm -f libvirt-rpms-http-server 2>/dev/null || true
          docker rm -f qemu-rpms-http-server 2>/dev/null || true
          echo "Custom RPM HTTP servers cleaned up"
